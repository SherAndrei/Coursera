# Структура LectureTitle

Дана структура LectureTitle:

```cpp
struct LectureTitle {
  string specialization;
  string course;
  string week;
};
```

Допишите конструктор и структуры Specialization, Course, Week так, чтобы объект LectureTitle можно было создать с помощью кода 

```cpp
LectureTitle title(
    Specialization("C++"),
    Course("White belt"),
    Week("4th")
);
```
но нельзя было с помощью следующих фрагментов кода:

```cpp
LectureTitle title("C++", "White belt", "4th");

LectureTitle title(string("C++"), string("White belt"), string("4th"));

LectureTitle title = {"C++", "White belt", "4th"};

LectureTitle title = {{"C++"}, {"White belt"}, {"4th"}};

LectureTitle title(
    Course("White belt"),
    Specialization("C++"),
    Week("4th")
);

LectureTitle title(
    Specialization("C++"),
    Week("4th"),
    Course("White belt")
);
```
### Решение
structLectureTitle.cpp

# Обратимая функция

Реализуйте рассказанный на лекции класс Function, позволяющий создавать, вычислять и инвертировать функцию, состоящую из следующих элементарных операций:
    прибавить вещественное число x;
    вычесть вещественное число x.

При этом необходимо объявить константными все методы, которые по сути такими являются.

Добавьте в класс Function из задачи «Обратимая функция» обработку умножения ('*') и деления ('/'). Гарантируется отсутствие элементарных операций умножения и деления на 0.

### Замечание
    Более детальное описание задачи с подробным разбором реализации вышеуказанного класса приводится в двух предшествующих видеолекциях.
    На проверку пришлите файл, содержащий реализацию вышеуказанного класса Function.

### Пример

Код

```cpp
struct Image {
  double quality;
  double freshness;
  double rating;
};

struct Params {
  double a;
  double b;
  double c;
};

Function MakeWeightFunction(const Params& params,
                            const Image& image) {
  Function function;
  function.AddPart('*', params.a);
  function.AddPart('-', image.freshness * params.b);
  function.AddPart('+', image.rating * params.c);
  return function;
}

double ComputeImageWeight(const Params& params, const Image& image) {
  Function function = MakeWeightFunction(params, image);
  return function.Apply(image.quality);
}

double ComputeQualityByWeight(const Params& params,
                              const Image& image,
                              double weight) {
  Function function = MakeWeightFunction(params, image);
  function.Invert();
  return function.Apply(weight);
}

int main() {
  Image image = {10, 2, 6};
  Params params = {4, 2, 6};
  cout << ComputeImageWeight(params, image) << endl;
  cout << ComputeQualityByWeight(params, image, 52) << endl;
  return 0;
}
```
Вывод

```
72
5
```

### Решение
 classInvertableFuncion.cpp

# Чтение и вывод таблицы

В первой строке файла input.txt записаны два числа N и M. Далее в файле находится таблица из N строк и M столбцов, представленная в формате CSV (comma-separated values). Такой формат часто используется для текстового представления таблиц с данными: в файле несколько строк, значения из разных ячеек внутри строки отделены друг от друга запятыми.  Ваша задача — вывести данные на экран в виде таблицы. Формат таблицы: 
* 1 размер ячейки равен 10, 
* 2 соседние ячейки отделены друг от друга пробелом,
* 3 последняя ячейка в строке НЕ оканчивается пробелом, 
* 4 последняя строка НЕ оканчивается символом перевода строки. Гарантируется, что в таблице будет ровно N строк и M столбцов, значение каждой из ячеек — целое число.

### Решение
 tables.cpp

# Список студентов

Определите структуру «Студент» со следующими полями: имя, фамилия, день, месяц и год рождения. Создайте вектор из таких структур, заполните его из входных данных и затем по запросам выведите нужные поля. Чтение и запись данных в этой задаче производится с использованием стандартных потоков.

### Формат ввода

Первая строка содержит одно целое число N от 0 до 10000 — число студентов.
Далее идут N строк, каждая из которых содержит две строки длиной от 1 до 15 символов — имя и фамилию очередного студента, и три целых числа от 0 до 1000000000 — день, месяц и год рождения.
Следующая строка содержит одно целое число M от 0 до 10000 — число запросов.
Следующие M строк содержат строку длиной от 1 до 15 символов — запрос, и целое число от 1 до 1000000000 — номер студента (нумерация начинается с 1).

### Формат вывода

Для запроса вида name K, где K от 1 до N, выведите через пробел имя и фамилию K-го студента.
Для запроса вида date K, где K от 1 до N, выведите через точку день, месяц и год рождения K-го студента.
Для остальных запросов выведите bad request.
NB: неверные запросы могут выходить за границы, указанные для данных.

### Решение
 StudentList.cpp

# Класс Rational

### Часть 1

В первой части Вам надо реализовать класс Rational, который представляет собой рациональное число вида p/q, где p — целое, а q — натуральное и диапазоны возможных значений p, q таковы, что могут быть представлены типом int. При этом, класс Rational должен иметь следующий интерфейс:

```cpp
class Rational {
public:
  Rational();
  Rational(int numerator, int denominator);

  int Numerator() const;
  int Denominator() const;
};
```
Класс Rational должен гарантировать, что p/q — это несократимая дробь.

Список требований, предъявляемых к реализации интерфейса класса Rational:
* Конструктор по умолчанию должен создавать дробь с числителем 0 и знаменателем 1.
* При конструировании объека класса Rational с параметрами p и q должно выполняться сокращение дроби p/q (здесь вам может пригодиться решение задачи «Наибольший общий делитель»).
* Если дробь p/q отрицательная, то объект Rational(p, q) должен иметь отрицательный числитель и положительный знаменатель.
* Если дробь p/q положительная, то объект Rational(p, q) должен иметь положительные числитель и знаменатель (обратите внимание на случай Rational(-2, -3)).
* Если числитель дроби равен нулю, то знаменатель должен быть равен 1.

Гарантируется, что ни в одном из тестов, на которых будет тестироваться ваша реализация, не будет знаменателя, равного нулю.

### Замечание

В стандарте языка C++17 для вычисления НОД имеется стандартная функция gcd. Допустимо использовать данную функцию для сокращения дробей. Подробнее с данной функцией и её ограничениями можно ознакомиться по ссылке: https://en.cppreference.com/w/cpp/numeric/gcd

### Часть 2

Реализуйте для класса Rational операторы ==, + и - так, чтобы операции с дробями можно было записывать естественным образом.

### Часть 3

Аналогично предыдущей части, реализуйте операторы * и /.

### Часть 4

В этой части вам нужно реализовать операторы ввода и вывода для класса Rational.

### Часть 5

Наконец, вам нужно реализовать возможность использовать объекты класса Rational в качестве элементов контейнера set и ключей в контейнере map.

### Решение 
 classRational.cpp

# Калькулятор обыкновенных дробей 

Итак, теперь у нас с вами есть полноценный тип для представления  обыкновенных дробей: класс Rational интегрирован в язык с помощью  перегрузки операторов и не позволяет выполнять некорректные операции за  счёт выбрасывания исключений. Давайте на основе класса Rational создадим  простой калькулятор для обыкновенных дробей.

Вам надо написать программу, которая считывает из стандартного ввода одну строку в формате ДРОБЬ_1 операция ДРОБЬ_2.  ДРОБЬ_1 и ДРОБЬ_2 имеют формат X/Y, где X — целое, а Y — целое неотрицательное число. операция — это один из символов '+', '-', '*', '/'.

Если ДРОБЬ_1 или ДРОБЬ_2 является  некорректной обыкновенной дробью, ваша программа должна вывести в  стандартный вывод сообщение "Invalid argument". Если считанная операция — это деление на ноль,  выведите в стандартный вывод сообщение  "Division by zero". В противном случае выведите результат операции.

### Решение
 RatianlCalculator.cpp

# Работа с сервером времени

Вам дана функция string AskTimeServer(), про которую известно следующее:
* в процессе своей работы она обращается по сети к удалённому серверу, запрашивая текущее время;
* если обращение к серверу прошло успешно, функция возвращает текущее время в виде строки;
* если в процессе обращения к серверу возникла сетевая проблема, функция выбрасывает исключение system_error;
* функция может выбрасывать другие исключения, чтобы сообщить о других проблемах.

Используя функцию AskTimeServer, напишите класс TimeServer со следующим интерфейсом:

```cpp
class TimeServer {
public:
  string GetCurrentTime();
private:
  string last_fetched_time = "00:00:00";
};
```
Метод GetCurrentTime должен вести себя так:
    он должен вызвать функцию AskTimeServer, записать её результат в поле last_fetched_time и вернуть значение этого поля;
    если AskTimeServer выбросила исключение system_error, метод GetCurrentTime должен его поймать и вернуть текущее значение поля last_fetched_time. Таким образом мы скрываем от пользователя сетевые проблемы, возвращая значение, которое было получено при последнем успешном обращении к серверу;
    если AskTimeServer выбросила другое исключение, метод GetCurrentTime должен пробросить его дальше, потому что в рамках класса TimeServer мы не знаем, как обрабатывать проблемы, не связанные со сбоями сети.

### Как выполнять задание

Вам дан файл, содержащий заготовку класса TimeServer. В нём вам надо реализовать метод GetCurrentTime так, как описано выше. Файл содержит пустую функцию AskTimeServer. Для тестирования своей реализации вы можете пробовать добавлять разные команды в её тело:
* возврат строки;
* выброс исключения system_error (класс system_error принимает в конструкторе параметр типа error_code, поэтому самый простой способ выбросить это исключение — throw system_error(error_code());, подробнее см. https://en.cppreference.com/w/cpp/error/system_error );
* выброс других исключений.

### Решение
 AskTimeServer.cpp
