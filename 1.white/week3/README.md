# Сортировка по модулю

В стандартном потоке дана одна строка, состоящая из N + 1 целых чисел. Первым числом идёт само число N. Далее следуют ещё N чисел, обозначим их за массив A. Между собой числа разделены пробелом.

Отсортируйте массив А по модулю и выведите его в стандартный поток.

### Ограниченя
    0 <= N <= 1000
    -1000000 <= A[i] <= 1000000


### Решение
 SortByAbs.cpp

# Сортировка без учета регистра

В стандартном потоке дана одна строка, состоящая из числа N и следующих за ним N строк S. Между собой число и строки разделены пробелом.
Отсортируйте строки S в лексикографическом порядке по возрастанию, игнорируя регистр букв, и выведите их в стандартный поток вывода.

### Ограниченя
    0 <= N <= 1000
    1 <= |S| <= 15
    Каждая строка S[i] может состоять из следующих символов: [0-9,a-z,A-Z]


### Решение
 SortCaseInsensitive.cpp

# Имена и фамилии 1

Реализуйте класс для человека, поддерживающий историю изменений человеком своих фамилии и имени.

```cpp
class Person {
public:
  void ChangeFirstName(int year, const string& first_name) {
    // добавить факт изменения имени на first_name в год year
  }
  void ChangeLastName(int year, const string& last_name) {
    // добавить факт изменения фамилии на last_name в год year
  }
  string GetFullName(int year) {
    // получить имя и фамилию по состоянию на конец года year
  }
private:
  // приватные поля
};
```

Считайте, что в каждый год может произойти не более одного изменения фамилии и не более одного изменения имени. При этом с течением времени могут открываться всё новые факты из прошлого человека, поэтому года́ в последовательных вызовах методов ChangeLastName и ChangeFirstName не обязаны возрастать.

Гарантируется, что все имена и фамилии непусты.

Строка, возвращаемая методом GetFullName, должна содержать разделённые одним пробелом имя и фамилию человека по состоянию на конец данного года.

    Если к данному году не случилось ни одного изменения фамилии и имени, верните строку "Incognito".
    Если к данному году случилось изменение фамилии, но не было ни одного изменения имени, верните "last_name with unknown first name".
    Если к данному году случилось изменение имени, но не было ни одного изменения фамилии, верните "first_name with unknown last name".


### Решение
 NamesSurnames1.cpp

# Имена и фамилии 2

Дополните класс из предыдущей задачи «Имена и фамилии — 1» методом GetFullNameWithHistory:

```cpp
class Person {
public:
  void ChangeFirstName(int year, const string& first_name) {
    // добавить факт изменения имени на first_name в год year
  }
  void ChangeLastName(int year, const string& last_name) {
    // добавить факт изменения фамилии на last_name в год year
  }
  string GetFullName(int year) {
    // получить имя и фамилию по состоянию на конец года year
  }
  string GetFullNameWithHistory(int year) {
    // получить все имена и фамилии по состоянию на конец года year
  }
private:
  // приватные поля
};
```
В отличие от метода GetFullName, метод GetFullNameWithHistory должен вернуть не только последние имя и фамилию к концу данного года, но ещё и все предыдущие имена и фамилии в обратном хронологическом порядке. Если текущие факты говорят о том, что человек два раза подряд изменил фамилию или имя на одно и то же, второе изменение при формировании истории нужно игнорировать.


### Решение
 NamesSurnames2.cpp

# Строка

Реализуйте класс ReversibleString, хранящий строку и поддерживающий методы Reverse для переворота строки и ToString для получения строки.  

### Решение
 ReversibleString.cpp

# Имена и фамилии 3

Дополните класс Person из задачи «Имена и фамилии — 2» конструктором, позволяющим задать имя и фамилию человека при рождении, а также сам год рождения. Класс не должен иметь конструктора по умолчанию.

При получении на вход года, который меньше года рождения:
    методы GetFullName и GetFullNameWithHistory должны отдавать "No person";
    методы ChangeFirstName и ChangeLastName должны игнорировать запрос.

Кроме того, необходимо объявить константными все методы, которые по сути ими являются.


### Решение
 NamesSurnames3.cpp

# Способы инициализации

Определите тип Incognizable, для которого следующий код будет корректен:

```cpp
int main() {
  Incognizable a;
  Incognizable b = {};
  Incognizable c = {0};
  Incognizable d = {0, 1};
  return 0;
}
```

### Решение
 Incognizable.cpp
