# Часть вектора

Напишите функцию PrintVectorPart, принимающую вектор целых чисел numbers, выполняющую поиск первого отрицательного числа в нём и выводящую в стандартный вывод все числа, расположенные левее найденного, в обратном порядке. Если вектор не содержит отрицательных чисел, выведите все числа в обратном порядке.

```cpp
void PrintVectorPart(const vector<int>& numbers);
```

### Решение
 PrintVectorPart.cpp

# Часть множества

Напишите шаблонную функцию FindGreaterElements, принимающую множество elements объектов типа T и ещё один объект border типа T и возвращающую вектор из всех элементов множества, бо́льших border, в возрастающем порядке.

```cpp
template <typename T>
vector<T> FindGreaterElements(const set<T>& elements, const T& border);
```

### Решение
 FindGreaterElementsInSet.cpp

# Разбиение на слова

Напишите функцию SplitIntoWords, разбивающую строку на слова по пробелам.

```cpp
vector<string> SplitIntoWords(const string& s);
```

Гарантируется, что:

* строка непуста;
* строка состоит лишь из латинских букв и пробелов;
* первый и последний символы строки не являются пробелами;
* строка не содержит двух пробелов подряд.

### Решение
 splitStringSpacesWithIters.cpp

# Удаление повторов

Напишите шаблонную функцию RemoveDuplicates, принимающую по ссылке вектор elements объектов типа T и удаляющую из него все дубликаты элементов. Порядок оставшихся элементов может быть любым.

Гарантируется, что объекты типа T можно сравнивать с помощью операторов ==, !=, < и >.

```cpp
template <typename T>
void RemoveDuplicates(vector<T>& elements);
```

### Решение
 RemoveDuplicatesVector.cpp

# Перебор перестановок

Дано целое положительное число N, не превышающее 9. Выведите все перестановки чисел от 1 до N в обратном лексикографическом порядке.

### Решение
 PermutatesInReverseOrder.cpp

# Демографические показатели

В этой задаче вам необходимо вычислить различные демографические показатели для группы людей. Человек представляется структурой Person:

```cpp
enum class Gender {
  FEMALE,
  MALE
};

struct Person {
  int age;  // возраст
  Gender gender;  // пол
  bool is_employed;  // имеет ли работу
};
```

Вам необходимо написать функцию PrintStats, получающую вектор людей, вычисляющую и выводящую медианный возраст для каждой из следующих групп людей:
* все люди;
* все женщины;
* все мужчины;
* все занятые женщины;
* все безработные женщины;
* все занятые мужчины;
* все безработные мужчины.

Все 7 чисел нужно вывести в строгом соответствии с форматом.
```cpp
void PrintStats(vector<Person> persons);
```

### Решение
 DemographicalIndicators.cpp

# Сортировка слиянием

Напишите шаблонную функцию MergeSort, принимающую два итератора шаблонного типа RandomIt и сортирующую заданный ими диапазон с помощью сортировки слиянием. Гарантируется, что:

* итераторы типа RandomIt аналогичны по функциональности итераторам вектора и строки, то есть их можно сравнивать с помощью операторов <, <=, > и >=, а также вычитать и складывать с числами;
* сортируемые объекты можно сравнивать с помощью оператора <.

## Часть 1

Классический алгоритм сортировки слиянием выглядит следующим образом:

1. Если диапазон содержит меньше 2 элементов, выйти из функции.
2. Создать вектор, содержащий все элементы текущего диапазона.
3. Разбить вектор на две равные части. (В этой задаче гарантируется, что длина передаваемого диапазона является степенью двойки, так что вектор всегда можно разбить на две равные части.)
4. Вызвать функцию MergeSort от каждой половины вектора.
5. С помощью алгоритма std::merge слить отсортированные половины, записав полученный отсортированный диапазон вместо исходного.

Вы должны реализовать именно этот алгоритм и никакой другой: тестирующая система будет проверять, что вы выполняете с элементами именно эти действия.

## Часть 2. Реализация с разбиением на 3 части

Реализуйте сортировку слиянием, разбивая диапазон на 3 равные части, а не на 2. Гарантируется, что длина исходного диапазона является степенью 3.

Соответственно, пункты 3–5 алгоритма нужно заменить следующими:

* Разбить вектор на 3 равные части.
* Вызвать функцию MergeSort от каждой части вектора.
* Слить первые две трети вектора с помощью алгоритма merge, сохранив результат во временный вектор с помощью back_inserter.
* Слить временный вектор из предыдущего пункта с последней третью вектора из п. 2, записав полученный отсортированный диапазон вместо исходного.

### Решение
 MergeSort.cpp

# Поиск ближайшего элемента

Напишите функцию FindNearestElement, для множества целых чисел numbers и данного числа border возвращающую итератор на элемент множества, ближайший к border. Если ближайших элементов несколько, верните итератор на наименьший из них.

```cpp
set<int>::const_iterator FindNearestElement(
    const set<int>& numbers,
    int border);
```

### Решение
 FindNearestElementInSet.cpp

# Имена и фамилии — 4 

Решите задачу «Имена и фамилии — 1» более эффективно, использовав двоичный поиск в методе Person::GetFullName.

### Решение
 NamesSurnames4.cpp

# Группировка строк по префиксу

## Часть 1

Напишите функцию FindStartsWith:

* принимающую отсортированный набор строк в виде итераторов range_begin, range_end и один символ prefix;
* возвращающую диапазон строк, начинающихся с символа prefix, в виде пары итераторов.

```cpp
template <typename RandomIt>
pair<RandomIt, RandomIt> FindStartsWith(
    RandomIt range_begin, RandomIt range_end,
    char prefix);
```

Если итоговый диапазон пуст, его границы должны указывать на то место в контейнере, куда можно без нарушения порядка сортировки вставить любую строку, начинающуюся с символа prefix (подобно алгоритму equal_range). Гарантируется, что строки состоят лишь из строчных латинских букв и символ prefix также является строчной латинской буквой.

Поиск должен осуществляться за логарифмическую сложность — например, с помощью двоичного поиска.

### Решение
 FindStartsWithChar.cpp

## Часть 2

Напишите более универсальный вариант функции FindStartsWith, принимающий в качестве префикса произвольную строку, состоящую из строчных латинских букв.

```cpp
template <typename RandomIt>
pair<RandomIt, RandomIt> FindStartsWith(
    RandomIt range_begin, RandomIt range_end,
    const string& prefix);
```

### Решение
 FindStartsWithString.cpp

# Построение арифметического выражения

## Часть 1

Реализуйте построение арифметического выражения согласно следующей схеме:

* изначально есть выражение, состоящее из некоторого целого числа x;
* на каждом шаге к текущему выражению применяется некоторая операция: прибавление числа, вычитание числа, умножение на число или деление на число; перед применением операции выражение всегда должно быть заключено в скобки.

### Формат ввода

В первой строке содержится исходное целое число x. Во второй строке содержится целое неотрицательное число N— количество операций. В каждой из следующих N строк содержится очередная операция:  

* прибавление числа a: + a;
* вычитание числа b: - b;
* умножение на число c: * c;
* деление на число d: / d.

Количество операций может быть нулевым — в этом случае необходимо вывести исходное число.

### Формат вывода

Выведите единственную строку — построенное арифметическое выражение.

Обратите внимание на расстановку пробелов вокруг символов:
* каждый символ бинарной операции (+, -, * или /) должен быть окружён ровно одним пробелом с каждой стороны: (8) * 3;
* символ унарного минуса (для отрицательных чисел) не нуждается в дополнительном пробеле: -5;
* скобки и числа не нуждаются в дополнительных пробелах.

### Решение
 MathExpressionWithBrackets.cpp

## Часть 2. Без лишних скобок

Модифицируйте решение предыдущей части так, чтобы предыдущее выражение обрамлялось скобками лишь при необходимости, то есть только в том случае, когда очередная операция имеет бо́льший приоритет, чем предыдущая.

### Решение
 MathExpressionWithoutBrackets.cpp
 